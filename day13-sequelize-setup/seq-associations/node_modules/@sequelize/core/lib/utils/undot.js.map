{
  "version": 3,
  "sources": ["../../src/utils/undot.ts"],
  "sourcesContent": ["/**\n * Tiny precompiler + setter to replace Dottie.transform for flat \"a.b[0].c\" keys.\n * Advantages:\n * - No deps\n * - Handles dot paths and [number] array indices\n * - Fast: pre-tokenizes keys once, then does straight-line writes\n *\n * some linting rules are skipped for performance optimizations.\n */\n\ntype PathSeg = string | number;\n\nexport interface CompiledPath {\n  sourceKey: string;\n  path: PathSeg[];\n}\n\nexport interface PrecompiledTransform {\n  // Dense array for tight loops\n  compiled: CompiledPath[];\n  // Quick lookups\n  index: Map<string, PathSeg[]>;\n}\n\n/**\n * Tokenize a single flat path like: \"a.b[0].c\"\n * - Dots split object keys\n * - Brackets with digits create numeric array indices\n * - Does NOT implement escaping / quoted keys; keep keys simple for max perf\n *\n * @param key The flat key to tokenize\n */\nexport function tokenizePath(key: string): PathSeg[] {\n  const out: PathSeg[] = [];\n  let i = 0;\n  const n = key.length;\n  let buf = '';\n\n  const flushBuf = () => {\n    if (buf.length) {\n      out.push(buf);\n      buf = '';\n    }\n  };\n\n  while (i < n) {\n    // disable linting rule for performance.\n    /* eslint-disable-next-line unicorn/prefer-code-point */\n    const ch = key.charCodeAt(i);\n    if (ch === 46 /* '.' */) {\n      flushBuf();\n      i++;\n      continue;\n    }\n\n    if (ch === 91 /* '[' */) {\n      // entering bracket\n      flushBuf();\n      i++;\n      let num = 0;\n      let hasDigit = false;\n      let hasClosingBracket = false;\n\n      // read digits until ']'\n      while (i < n) {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        const c = key.charCodeAt(i);\n        if (c >= 48 && c <= 57) {\n          hasDigit = true;\n          num = num * 10 + (c - 48);\n          i++;\n          continue;\n        }\n\n        if (c === 93 /* ']' */) {\n          hasClosingBracket = true;\n          i++;\n          break;\n        }\n\n        // Non-digit inside brackets: fallback to simple behavior (treat as text)\n        // For perf, this doesn't support [\"complex.key\"] patterns.\n        throw new Error(`Unsupported bracket syntax in key: ${key}`);\n      }\n\n      if (!hasClosingBracket) {\n        throw new Error(`Unterminated bracket in key: ${key}`);\n      }\n\n      if (!hasDigit) {\n        throw new Error(`Empty or non-numeric bracket in key: ${key}`);\n      }\n\n      out.push(num);\n      continue;\n    }\n\n    // normal char\n    buf += key[i++];\n  }\n\n  flushBuf();\n\n  return out;\n}\n\n/**\n * Precompile all keys once per result-set shape.\n * Pass in the enumerable keys you will transform (e.g., Object.keys(row)).\n *\n * @param keys The flat keys to precompile\n */\nexport function precompileKeys(keys: readonly string[]): PrecompiledTransform {\n  /* eslint-disable-next-line unicorn/no-new-array */\n  const compiled: CompiledPath[] = new Array(keys.length);\n  const index = new Map<string, PathSeg[]>();\n\n  // disable linting rule for performance.\n  /* eslint-disable-next-line unicorn/no-for-loop */\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i];\n    // Fast path: if no '.' and no '[' then it\u2019s a direct write, store a single string seg\n\n    // eslint-disable-next-line @typescript-eslint/prefer-includes, unicorn/prefer-includes  -- disabled for performance\n    const hasDot = k.indexOf('.') >= 0;\n    /* eslint-disable-next-line @typescript-eslint/prefer-includes, unicorn/prefer-includes  */\n    const hasBracket = k.indexOf('[') >= 0;\n\n    const path = hasDot || hasBracket ? tokenizePath(k) : [k];\n\n    compiled[i] = { sourceKey: k, path };\n    index.set(k, path);\n  }\n\n  return { compiled, index };\n}\n\n/**\n * Set a value by a tokenized path on the target, creating intermediate objects/arrays.\n * Creates arrays when the next segment is a number, objects otherwise.\n *\n * @param target The target object to set the value on\n * @param path The tokenized path array\n * @param value The value to set\n */\nexport function setByPathArray(\n  target: Record<string, unknown>,\n  path: readonly PathSeg[],\n  value: unknown,\n): void {\n  let obj: any = target;\n  const last = path.length - 1;\n\n  for (let i = 0; i < last; i++) {\n    const seg = path[i];\n    const nextIsIndex = typeof path[i + 1] === 'number';\n\n    if (typeof seg === 'number') {\n      // current should be array\n      if (!Array.isArray(obj)) {\n        // If we somehow landed on non-array (mis-shaped), replace it\n        obj = [];\n      }\n      // Ensure parent points to this array (caller must have assigned obj)\n      // But because we always assign at parent step, we only need to ensure slot exists\n\n      if (obj[seg] == null) {\n        obj[seg] = nextIsIndex ? [] : {};\n      }\n\n      obj = obj[seg];\n    } else {\n      // object seg\n      let next = obj[seg];\n      if (next == null || (typeof next !== 'object' && !Array.isArray(next))) {\n        obj[seg] = nextIsIndex ? [] : {};\n        next = obj[seg];\n      }\n\n      obj = next;\n    }\n  }\n\n  const leaf = path[last];\n  obj[leaf] = value;\n}\n\n/**\n * Transform a flat row with precompiled paths into a nested object.\n * Optionally reuse an output object (e.g., from a pool) for fewer allocations.\n *\n * @param row The flat row object to transform\n * @param pre The precompiled transform data\n * @param out Optional output object to reuse\n */\nexport function transformRowWithPrecompiled(\n  row: Record<string, unknown>,\n  pre: PrecompiledTransform,\n  out?: Record<string, unknown>,\n): Record<string, unknown> {\n  const target = out ?? {};\n  const { compiled } = pre;\n  // eslint-disable-next-line unicorn/no-for-loop -- disabled for performance\n  for (let i = 0; i < compiled.length; i++) {\n    const { sourceKey, path } = compiled[i];\n    const v = (row as any)[sourceKey];\n    // Skip undefineds to mimic common transform behavior (optional)\n    if (v !== undefined) {\n      setByPathArray(target, path, v);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Acquire an object from a simple pool and clear its own keys.\n *\n * @param pool Pool of reusable plain objects\n * @returns A cleared object ready for reuse\n */\nexport function acquirePooledObject(pool: Array<Record<string, unknown>>): Record<string, unknown> {\n  const obj = pool.pop();\n  if (!obj) {\n    return {};\n  }\n  // Clear previous contents\n\n  const keys = Object.keys(obj);\n  // disable linting rule for performance.\n  /* eslint-disable-next-line unicorn/no-for-loop */\n  for (let i = 0; i < keys.length; i++) {\n    delete (obj as any)[keys[i]];\n  }\n\n  return obj;\n}\n\nexport function releasePooledObject(\n  pool: Array<Record<string, unknown>>,\n  obj: Record<string, unknown>,\n): void {\n  pool.push(obj);\n}\n"],
  "mappings": "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",
  "names": []
}
