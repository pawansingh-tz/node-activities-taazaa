{
  "version": 3,
  "sources": ["../../src/abstract-dialect/query.ts"],
  "sourcesContent": ["/* eslint-disable unicorn/no-for-loop */\n\n// We're disabling the unicorn/no-for-loop rule in this file\n// because we need the performance benefits of traditional for-loops\n// and JIT compilers love the reduced complexity\n\n/**\n * Abstract query utilities and base implementation used by all dialects.\n *\n * This module contains:\n * - The `AbstractQuery` base class used by dialect query implementations.\n * - Helper utilities to post-process raw result sets into nested include graphs.\n * - Internal hashing and grouping logic for JOIN de-duplication.\n *\n * All symbols are documented for Typedoc/JSDoc consumption. Unless marked otherwise,\n * everything in this file is considered internal to Sequelize's query pipeline.\n */\nimport isEmpty from 'lodash/isEmpty';\nimport { randomUUID } from 'node:crypto';\nimport NodeUtil from 'node:util';\nimport type { Association } from '../associations';\nimport { QueryTypes } from '../enums';\nimport type { BuildOptions, IncludeOptions, Model, ModelStatic } from '../model';\nimport type { Sequelize } from '../sequelize';\nimport * as deprecations from '../utils/deprecations';\nimport type { PrecompiledTransform } from '../utils/undot';\nimport {\n  precompileKeys,\n  setByPathArray,\n  tokenizePath,\n  transformRowWithPrecompiled,\n} from '../utils/undot';\nimport type { AbstractConnection } from './connection-manager';\nimport type { NormalizedDataType } from './data-types';\nimport { AbstractDataType } from './data-types';\n\n/**\n * Cache of unique-key attribute name arrays per model.\n * Used by JOIN de-duplication and hashing to avoid repeated model inspection.\n */\nconst uniqueKeyAttributesCache = new WeakMap<ModelStatic, readonly string[]>();\n\n/**\n * Cache mapping a model to a mapping from column name -> attribute name.\n * Accelerates resolving attribute names from raw column identifiers.\n */\nconst columnAttributeNameCache = new WeakMap<ModelStatic, Map<string, string>>();\n\n/**\n * Include options extended with pre-resolved model and a fast lookup map for child includes.\n */\ninterface IncludeOptionsWithMap extends IncludeOptions {\n  /**\n   * Model associated to this include (present after include resolution).\n   */\n  model?: ModelStatic;\n  /**\n   * Map of child include name -> include options for constant-time lookups.\n   */\n  includeMap?: Record<string, IncludeOptionsWithMap | undefined>;\n}\n\n/**\n * Lookup table from dotted include path (e.g., \"posts.comments\") to the corresponding include options.\n */\ntype IncludeMap = Record<string, IncludeOptionsWithMap | undefined>;\n\n/**\n * The root include options used when grouping JOINed rows. Root must always have a model.\n */\ntype RootIncludeOptions = IncludeOptionsWithMap & {\n  /** The root model for the query. */\n  model: ModelStatic;\n  /**\n   * List of include names in resolution order; used by model building.\n   */\n  includeNames?: readonly string[];\n};\n\n/**\n * Internal options passed to `Model.bulkBuild` when materializing rows.\n */\ninterface BulkBuildOptionsInternal extends BuildOptions {\n  /** Names of includes applied to the rows. */\n  includeNames?: readonly string[] | undefined;\n  /** Resolved include map for nested parsing. */\n  includeMap?: IncludeMap | undefined;\n  /** Whether include configuration was already validated. */\n  includeValidated?: boolean | undefined;\n  /** Attributes that were originally requested (pre-alias). */\n  attributes?: readonly string[] | undefined;\n  /** Hints that data originates from the DB rather than user input. */\n  comesFromDatabase?: boolean | undefined;\n}\n\n/**\n * Hash information for a single node of a joined graph.\n */\ninterface HashEntry {\n  /** The computed hash for the current item (includes parent hash prefix). */\n  itemHash: string;\n  /** The computed hash for the parent item, or null if at the root. */\n  parentHash: string | null;\n}\n\n/**\n * Legacy unique key definition shape used by historical model definitions.\n */\ntype LegacyUniqueKeyDefinition = { fields?: readonly string[] };\n\n/**\n * Model type guard for models that expose legacy `uniqueKeys` metadata.\n */\ntype ModelWithLegacyUniqueKeys = ModelStatic & {\n  /** A record of legacy unique keys keyed by name. */\n  uniqueKeys?: Record<string, LegacyUniqueKeyDefinition>;\n};\n\n/**\n * Metadata describing a single dotted key in the raw result set and how it maps into the include tree.\n */\ntype metaEntry = {\n  /** The full raw dotted key (e.g., \"posts.comments.id\"). */\n  key: string;\n  /** The attribute portion of the key (segment after the last dot). */\n  attribute: string;\n  /** The dotted path segments leading to the attribute. */\n  prefixParts: readonly string[];\n  /** Number of segments in `prefixParts`. */\n  prefixLength: number;\n  /** The dotted prefix id (e.g., \"posts.comments\"). */\n  prefixId: string;\n  /** The last segment of the prefix (e.g., \"comments\"). */\n  lastKeySegment: string;\n  /** Resolved include options for this prefix, if any. */\n  include: IncludeOptionsWithMap | undefined;\n  /** The parent prefix id (one level up). */\n  parentPrefixId: string;\n  /** The primary key attributes of the model at this prefix. */\n  primaryKeyAttributes: readonly string[];\n  /** Fallback unique key attributes, if PKs are absent. */\n  uniqueKeyAttributes: readonly string[];\n  /** Fully-qualified row keys used to compute the hash for this prefix. */\n  hashAttributeRowKeys: readonly string[];\n};\n\n/**\n * Resolves the attribute name corresponding to a column or attribute identifier.\n *\n * If the identifier is already an attribute name present in the model definition,\n * it is returned as-is. Otherwise, a per-model cache mapping column names to\n * attribute names is consulted (and lazily populated) to resolve the attribute name.\n *\n * @param model - The Sequelize model to resolve against.\n * @param columnOrAttribute - A column name (DB) or attribute name (model).\n * @returns The resolved attribute name if known, otherwise `columnOrAttribute`.\n */\nfunction getAttributeNameFromColumn(model: ModelStatic, columnOrAttribute: string): string {\n  const definition = model.modelDefinition;\n\n  if (definition.attributes.has(columnOrAttribute)) {\n    return columnOrAttribute;\n  }\n\n  let cache = columnAttributeNameCache.get(model);\n  if (!cache) {\n    cache = new Map<string, string>();\n    for (const attribute of definition.attributes.values()) {\n      cache.set(attribute.columnName, attribute.attributeName);\n    }\n\n    columnAttributeNameCache.set(model, cache);\n  }\n\n  return cache.get(columnOrAttribute) ?? columnOrAttribute;\n}\n\n/**\n * Produces a shallow copy of a row with keys remapped according to `fieldMap`.\n * Keys present in `fieldMap` are renamed; original keys are removed.\n *\n * @param row - The input row to transform.\n * @param fieldMap - Mapping from \"from\" key -> \"to\" key.\n * @returns A new object containing the remapped fields.\n */\nfunction remapRowFields(\n  row: Record<string, unknown>,\n  fieldMap: Record<string, string>,\n): Record<string, unknown> {\n  const output: Record<string, unknown> = { ...row };\n\n  const fields = Object.keys(fieldMap);\n\n  for (let index = 0; index < fields.length; ++index) {\n    const field = fields[index];\n    const name = fieldMap[field];\n\n    if (field in output && name !== field) {\n      output[name] = output[field];\n      delete output[field];\n    }\n  }\n\n  return output;\n}\n\n/**\n * Runtime type guard to determine whether a value implements the iterator protocol.\n *\n * @param value - The value to check.\n * @returns `true` if the value is iterable, `false` otherwise.\n */\nfunction isIterable(value: unknown): value is Iterable<unknown> {\n  return value != null && typeof (value as Iterable<unknown>)[Symbol.iterator] === 'function';\n}\n\n/**\n * Extracts an `Association` from an include option only when it has been resolved.\n *\n * @param association - The include's `association` property.\n * @returns The `Association` instance if available, otherwise `undefined`.\n */\nfunction extractAssociation(\n  association: IncludeOptions['association'] | undefined,\n): Association | undefined {\n  if (association && typeof association === 'object') {\n    return association;\n  }\n\n  return undefined;\n}\n\n/**\n * Builds the list of fully-qualified row keys used for hashing at a given include prefix.\n *\n * @param prefixId - Dotted path to the include prefix (e.g., \"posts.comments\").\n * @param primaryKeyAttributes - Primary key attribute names for the model at the prefix.\n * @param uniqueKeyAttributes - Fallback unique attribute names if PKs are absent.\n * @returns An array of keys to read from a raw row for hashing.\n */\nfunction buildHashAttributeRowKeys(\n  prefixId: string,\n  primaryKeyAttributes: readonly string[],\n  uniqueKeyAttributes: readonly string[],\n): readonly string[] {\n  const attributeNames =\n    primaryKeyAttributes.length > 0 ? primaryKeyAttributes : uniqueKeyAttributes;\n\n  if (attributeNames.length === 0) {\n    return [];\n  }\n\n  const rowKeyPrefix = prefixId ? `${prefixId}.` : '';\n\n  return attributeNames.map(attributeName => `${rowKeyPrefix}${attributeName}`);\n}\n\n/**\n * Result of attaching an existing segment during de-duplication.\n */\ntype ExistingSegmentResult = {\n  /** The next scratch object to receive subsequent attributes. */\n  nextValues: Record<string, unknown>;\n  /** Indicates whether the top-level container already existed. */\n  topExists: boolean;\n};\n\n/**\n * Computes the hash values for a particular meta entry, delegating to `getHashesForPrefix`.\n * Optimizes the root prefix by returning the provided root hash entry.\n *\n * @param meta - The meta entry describing the current segment.\n * @param row - The current raw row.\n * @param includeMap - The include lookup map.\n * @param prefixMeta - Metadata per prefix, used to infer parent/child relations.\n * @param topHashEntry - Pre-computed hash entry for the root item.\n * @param prefixHashCache - Optional memoization cache.\n * @returns The computed `HashEntry` for this meta.\n */\nfunction computeHashesForMeta(\n  meta: metaEntry,\n  row: Record<string, unknown>,\n  includeMap: IncludeMap,\n  prefixMeta: Map<string, metaEntry>,\n  topHashEntry: HashEntry,\n  prefixHashCache: Map<string, HashEntry> | undefined,\n): HashEntry {\n  if (meta.prefixLength === 0) {\n    return topHashEntry;\n  }\n\n  return getHashesForPrefix(\n    meta.prefixId,\n    row,\n    includeMap,\n    prefixMeta,\n    topHashEntry.itemHash,\n    prefixHashCache,\n  );\n}\n\n/**\n * Attaches a child object into its parent at the include key, handling both\n * single-association (assign) and multi-association (array push) cases.\n *\n * No-ops if the parent container cannot be found (e.g., filtered out by hashing).\n *\n * @param meta - Meta information describing the relationship and key.\n * @param parentHash - Hash of the parent container; `null` for root.\n * @param resultMap - Global map of hash -> container.\n * @param childValues - The child object to attach.\n */\nfunction attachToParent(\n  meta: metaEntry,\n  parentHash: string | null,\n  resultMap: Record<string, Record<string, unknown>>,\n  childValues: Record<string, unknown>,\n): void {\n  if (!parentHash) {\n    return;\n  }\n\n  const parentContainer = resultMap[parentHash];\n  if (!parentContainer) {\n    return;\n  }\n\n  const association = extractAssociation(meta.include?.association);\n  const associationKey = meta.lastKeySegment;\n\n  if (!association || !association.isMultiAssociation) {\n    parentContainer[associationKey] = childValues;\n\n    return;\n  }\n\n  let associationValues = parentContainer[associationKey];\n  if (!Array.isArray(associationValues)) {\n    const newAssociationValues: Array<Record<string, unknown>> = [];\n    parentContainer[associationKey] = newAssociationValues;\n    associationValues = newAssociationValues;\n  }\n\n  (associationValues as Array<Record<string, unknown>>).push(childValues);\n}\n\n/**\n * Retrieves a reusable plain object from the pool, clearing previous contents.\n *\n * @param pool - Pool of reusable objects.\n * @returns An emptied object ready for population.\n */\nfunction acquireValuesObject(pool: Array<Record<string, unknown>>): Record<string, unknown> {\n  const reusable = pool.pop();\n  if (!reusable) {\n    return {};\n  }\n\n  const keys = Object.keys(reusable);\n  for (let i = 0; i < keys.length; i++) {\n    delete reusable[keys[i]];\n  }\n\n  return reusable;\n}\n\n/**\n * Returns an object to the reuse pool after the caller is done with it.\n *\n * @param pool - Pool to return the object to.\n * @param obj - Object to recycle.\n */\nfunction releaseValuesObject(\n  pool: Array<Record<string, unknown>>,\n  obj: Record<string, unknown>,\n): void {\n  pool.push(obj);\n}\n\n/**\n * Handles the transition between prefixes in deduplication mode:\n * - hashes the previous prefix\n * - attaches its container into the result map if needed\n * - releases unused containers\n * - returns a fresh container for the next prefix\n *\n * @param previousMeta - Metadata for the previous prefix.\n * @param row - Current raw row.\n * @param includeMap - Include lookup map.\n * @param prefixMeta - Metadata per prefix id.\n * @param prefixHashCache - Optional hash cache.\n * @param currentValues - Container holding the previous prefix's attributes.\n * @param resultMap - Global hash -> container map.\n * @param freeList - Pool of reusable containers.\n * @param topHashEntry - Hash entry representing the root object.\n * @returns The next container and whether the top already existed.\n */\nfunction attachExistingSegment(\n  previousMeta: metaEntry,\n  row: Record<string, unknown>,\n  includeMap: IncludeMap,\n  prefixMeta: Map<string, metaEntry>,\n  prefixHashCache: Map<string, HashEntry> | undefined,\n  currentValues: Record<string, unknown>,\n  resultMap: Record<string, Record<string, unknown>>,\n  freeList: Array<Record<string, unknown>>,\n  topHashEntry: HashEntry,\n): ExistingSegmentResult {\n  const hashes = computeHashesForMeta(\n    previousMeta,\n    row,\n    includeMap,\n    prefixMeta,\n    topHashEntry,\n    prefixHashCache,\n  );\n  const nextValues = acquireValuesObject(freeList);\n\n  if (hashes.itemHash === topHashEntry.itemHash) {\n    if (!resultMap[topHashEntry.itemHash]) {\n      resultMap[topHashEntry.itemHash] = currentValues;\n\n      return { nextValues, topExists: false };\n    }\n\n    releaseValuesObject(freeList, currentValues);\n\n    return { nextValues, topExists: true };\n  }\n\n  if (!resultMap[hashes.itemHash]) {\n    resultMap[hashes.itemHash] = currentValues;\n    attachToParent(previousMeta, hashes.parentHash, resultMap, currentValues);\n  } else {\n    releaseValuesObject(freeList, currentValues);\n  }\n\n  return { nextValues, topExists: false };\n}\n\n/**\n * Ensures that the nested object chain exists for the given `meta` prefix and\n * returns the container into which attributes for this prefix should be written.\n * Used when de-duplication is disabled.\n *\n * @param topValues - The root output object for the current row.\n * @param meta - Meta describing the current prefix path.\n * @returns The nested container for this prefix.\n */\nfunction ensureNestedContainer(\n  topValues: Record<string, unknown>,\n  meta: metaEntry,\n): Record<string, unknown> {\n  if (meta.prefixLength === 0) {\n    return topValues;\n  }\n\n  let current = topValues;\n  const { prefixParts, prefixLength } = meta;\n\n  for (let index = 0; index < prefixLength; ++index) {\n    const part = prefixParts[index];\n    if (index === prefixLength - 1) {\n      if (typeof current[part] !== 'object' || current[part] == null) {\n        current[part] = {};\n      }\n\n      return current[part] as Record<string, unknown>;\n    }\n\n    if (typeof current[part] !== 'object' || current[part] == null) {\n      current[part] = {};\n    }\n\n    current = current[part] as Record<string, unknown>;\n  }\n\n  return current;\n}\n\n/**\n * Finalizes the wiring of the last processed segment in a deduplicated row and\n * returns whether the top-level container already existed in `resultMap`.\n *\n * @param previousMeta - The meta of the last processed key.\n * @param row - The current raw row.\n * @param includeMap - Include lookup map.\n * @param prefixMeta - Metadata per prefix id.\n * @param prefixHashCache - Hash memoization cache.\n * @param currentValues - The object containing attributes of the last segment.\n * @param resultMap - Global map of hash -> container.\n * @param currentTopExists - Whether the root already existed before finalization.\n * @param freeList - Pool used to recycle unused containers.\n * @param topHashEntry - Pre-computed root hash entry for the current row.\n * @returns The updated `topExists` state.\n */\nfunction finalizeExistingRow(\n  previousMeta: metaEntry,\n  row: Record<string, unknown>,\n  includeMap: IncludeMap,\n  prefixMeta: Map<string, metaEntry>,\n  prefixHashCache: Map<string, HashEntry> | undefined,\n  currentValues: Record<string, unknown>,\n  resultMap: Record<string, Record<string, unknown>>,\n  currentTopExists: boolean,\n  freeList: Array<Record<string, unknown>>,\n  topHashEntry: HashEntry,\n): boolean {\n  const hashes = computeHashesForMeta(\n    previousMeta,\n    row,\n    includeMap,\n    prefixMeta,\n    topHashEntry,\n    prefixHashCache,\n  );\n  if (hashes.itemHash === topHashEntry.itemHash) {\n    if (!resultMap[topHashEntry.itemHash]) {\n      resultMap[topHashEntry.itemHash] = currentValues;\n\n      return currentTopExists;\n    }\n\n    releaseValuesObject(freeList, currentValues);\n\n    return true;\n  }\n\n  if (!resultMap[hashes.itemHash]) {\n    resultMap[hashes.itemHash] = currentValues;\n    attachToParent(previousMeta, hashes.parentHash, resultMap, currentValues);\n  } else {\n    releaseValuesObject(freeList, currentValues);\n  }\n\n  return currentTopExists;\n}\n\n/**\n * Resolves and caches the include options matching a dotted raw key by traversing\n * the `includeMap` chain. Intermediate segments are memoized to speed up future lookups.\n *\n * @param rawKey - The full dotted key from the result set.\n * @param prefixParts - The path segments preceding the attribute.\n * @param rootInclude - The root include options.\n * @param includeMap - The lookup map to populate.\n * @returns The resolved include options for the key, if any.\n */\nfunction resolveIncludeForKey(\n  rawKey: string,\n  prefixParts: readonly string[],\n  rootInclude: IncludeOptionsWithMap,\n  includeMap: IncludeMap,\n): IncludeOptionsWithMap | undefined {\n  if (prefixParts.length === 0) {\n    includeMap[rawKey] = rootInclude;\n    includeMap[''] = rootInclude;\n\n    return rootInclude;\n  }\n\n  let currentInclude: IncludeOptionsWithMap | undefined = rootInclude;\n  let accumulatedPath: string | undefined;\n\n  for (let i = 0; i < prefixParts.length; i++) {\n    const piece = prefixParts[i];\n    currentInclude = currentInclude?.includeMap?.[piece];\n    if (!currentInclude) {\n      return undefined;\n    }\n\n    accumulatedPath = accumulatedPath ? `${accumulatedPath}.${piece}` : piece;\n    includeMap[accumulatedPath] = currentInclude;\n  }\n\n  includeMap[rawKey] = currentInclude;\n\n  return currentInclude;\n}\n\n/**\n * Retrieves the attribute names that form the first unique key in a model, mapping\n * column names to attribute names when necessary. Results are cached per model.\n *\n * @param model - The Sequelize model to inspect.\n * @returns A (possibly empty) array of attribute names for a unique key.\n */\nfunction getUniqueKeyAttributes(model: ModelStatic): readonly string[] {\n  const cached = uniqueKeyAttributesCache.get(model);\n  if (cached) {\n    return cached;\n  }\n\n  const uniqueKeys = (model as ModelWithLegacyUniqueKeys).uniqueKeys ?? {};\n  const uniqueKeyAttributes: string[] = [];\n\n  if (!isEmpty(uniqueKeys)) {\n    const [firstUniqueKeyName] = Object.keys(uniqueKeys);\n    const uniqueKey = firstUniqueKeyName ? uniqueKeys[firstUniqueKeyName] : undefined;\n    const fields: readonly unknown[] = uniqueKey?.fields ?? [];\n\n    for (let fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {\n      const field = fields[fieldIndex];\n      if (typeof field !== 'string') {\n        continue;\n      }\n\n      uniqueKeyAttributes.push(getAttributeNameFromColumn(model, field));\n    }\n  }\n\n  uniqueKeyAttributesCache.set(model, uniqueKeyAttributes);\n\n  return uniqueKeyAttributes;\n}\n\n/**\n * Sorts dotted keys so that shallower paths (parents) come before deeper ones (children).\n * This ordering ensures prefix metadata is computed in dependency order.\n *\n * @param inputKeys - The array of dotted keys to sort (mutated in-place by `sort`).\n * @returns The sorted `inputKeys` reference.\n */\nfunction sortByDepth(inputKeys: string[]) {\n  return inputKeys.sort((a, b) => a.split('.').length - b.split('.').length);\n}\n\n/**\n * Converts a value into a string suitable for hash concatenation. Buffers are rendered as hex.\n *\n * @param obj - The value to stringify.\n * @returns The string representation used for hashing.\n */\nfunction stringify(obj: unknown) {\n  return obj instanceof Buffer ? obj.toString('hex') : (obj?.toString() ?? '');\n}\n\n/**\n * Generates a deterministic hash for a single raw row for the provided model.\n * Priority of attributes used:\n * 1) Primary keys\n * 2) First legacy unique key definition (if any)\n * 3) First unique index fields (string fields only)\n *\n * @param model - The model whose identity should be represented by the hash.\n * @param row - The row object to read values from.\n * @returns A stable string hash composed by concatenating selected attribute values.\n */\nfunction getHash(model: ModelStatic, row: Record<string, unknown>): string {\n  const strings: string[] = [];\n  const primaryKeyAttributes = model.modelDefinition.primaryKeysAttributeNames;\n\n  if (primaryKeyAttributes.size > 0) {\n    for (const attributeName of primaryKeyAttributes) {\n      strings.push(stringify(row[attributeName]));\n    }\n  } else {\n    const uniqueKeyAttributes = getUniqueKeyAttributes(model);\n    for (let i = 0; i < uniqueKeyAttributes.length; i++) {\n      const attributeName = uniqueKeyAttributes[i];\n      strings.push(stringify(row[attributeName]));\n    }\n  }\n\n  if (isEmpty(strings) && !isEmpty(model.getIndexes())) {\n    for (let i = 0; i < model.getIndexes().length; i++) {\n      const index = model.getIndexes()[i];\n      if (!index.unique || !index.fields) {\n        continue;\n      }\n\n      for (let j = 0; j < index.fields.length; j++) {\n        const field = index.fields[j];\n        // Skip function-based or literal index fields - we can only hash simple attribute names\n        if (typeof field !== 'string') {\n          continue;\n        }\n\n        const attributeName = getAttributeNameFromColumn(model, field);\n        strings.push(stringify(row[attributeName]));\n      }\n\n      break; // Only use the first unique index, matching getUniqueKeyAttributes logic\n    }\n  }\n\n  return strings.join('');\n}\n\n/**\n * Returns or computes the `HashEntry` for the given dotted include prefix.\n *\n * The hash of an item is defined as `parentHash + prefix + attributeValues`, where\n * `attributeValues` are the PK or unique key values at this prefix. This makes each\n * child's hash dependent on its parent, preventing collisions across siblings.\n *\n * @param prefix - The dotted include prefix (empty string for root).\n * @param currentRow - The current raw row.\n * @param currentIncludeMap - Include lookup map.\n * @param currentPrefixMeta - Metadata per prefix id.\n * @param currentTopHash - Root hash for the current row.\n * @param prefixHashCache - Optional memoization cache shared within the row.\n * @returns The computed `HashEntry` for the prefix.\n */\nfunction getHashesForPrefix(\n  prefix: string,\n  currentRow: Record<string, unknown>,\n  currentIncludeMap: IncludeMap,\n  currentPrefixMeta: Map<string, metaEntry>,\n  currentTopHash: string,\n  prefixHashCache?: Map<string, HashEntry>,\n): HashEntry {\n  const cache = prefixHashCache ?? new Map<string, HashEntry>();\n\n  if (!cache.has('')) {\n    cache.set('', { itemHash: currentTopHash, parentHash: null });\n  }\n\n  if (prefix === '') {\n    return cache.get('')!;\n  }\n\n  const cached = cache.get(prefix);\n  if (cached) {\n    return cached;\n  }\n\n  const prefixInfo = currentPrefixMeta.get(prefix);\n  const include = currentIncludeMap[prefix] ?? prefixInfo?.include;\n  if (!include?.model) {\n    return cache.get('')!;\n  }\n\n  const hashParts: string[] = [prefix];\n  let hashAttributeRowKeys = prefixInfo?.hashAttributeRowKeys ?? [];\n\n  if (hashAttributeRowKeys.length === 0) {\n    const primaryKeyAttributes = prefixInfo?.primaryKeyAttributes?.length\n      ? prefixInfo.primaryKeyAttributes\n      : [...include.model.modelDefinition.primaryKeysAttributeNames.values()];\n\n    let attributesToHash = primaryKeyAttributes;\n\n    if (attributesToHash.length === 0) {\n      const uniqueKeyAttributes = prefixInfo?.uniqueKeyAttributes?.length\n        ? prefixInfo.uniqueKeyAttributes\n        : getUniqueKeyAttributes(include.model);\n\n      attributesToHash = uniqueKeyAttributes;\n    }\n\n    if (attributesToHash.length > 0) {\n      const rowKeyPrefix = prefix ? `${prefix}.` : '';\n      hashAttributeRowKeys = attributesToHash.map(\n        attributeName => `${rowKeyPrefix}${attributeName}`,\n      );\n      if (prefixInfo) {\n        prefixInfo.hashAttributeRowKeys = hashAttributeRowKeys;\n      }\n    }\n  }\n\n  if (hashAttributeRowKeys.length > 0) {\n    for (let k = 0; k < hashAttributeRowKeys.length; k++) {\n      const attributeKey = hashAttributeRowKeys[k];\n      hashParts.push(stringify(currentRow[attributeKey]));\n    }\n  }\n\n  const parentPrefix =\n    prefixInfo?.parentPrefixId ??\n    (prefix.includes('.') ? prefix.slice(0, prefix.lastIndexOf('.')) : '');\n  const parentHashes = getHashesForPrefix(\n    parentPrefix,\n    currentRow,\n    currentIncludeMap,\n    currentPrefixMeta,\n    currentTopHash,\n    cache,\n  );\n  const parentHashValue = parentHashes.itemHash;\n\n  const hash = hashParts.join('');\n  const result: HashEntry = {\n    itemHash: parentHashValue + hash,\n    parentHash: parentHashValue,\n  };\n  cache.set(prefix, result);\n\n  return result;\n}\n\nexport interface AbstractQueryGroupJoinDataOptions {\n  /**\n   * Whether to de-duplicate rows by hashing PK/unique keys when grouping JOIN results.\n   * If `false`, rows are nested directly without deduplication (faster for no-join queries).\n   */\n  checkExisting: boolean;\n}\n\nexport interface AbstractQueryOptions {\n  /** The instance being operated on (e.g., for INSERT/UPDATE). */\n  instance?: Model;\n  /** The model associated with this query. */\n  model?: ModelStatic;\n  /** The query type used to adjust result processing. */\n  type?: QueryTypes;\n  /** Map from raw column name to model attribute name, or `true` to disable. */\n  fieldMap?: Record<string, string> | boolean;\n  /** If `true`, returns only the first row (or `null`). */\n  plain: boolean;\n  /** If `true`, returns raw objects instead of model instances. */\n  raw: boolean;\n  /** If `true`, uses dotted key nesting for raw results. */\n  nest?: boolean;\n  /** Internal flag indicating that the select has JOINs. */\n  hasJoin?: boolean;\n  /** Internal flag indicating presence of a multi association. */\n  hasMultiAssociation?: boolean;\n  /** Logging function or `false` to disable; `true` is deprecated. */\n  logging?: boolean | ((sql: string, timing?: number) => void);\n  /** If `true`, emits benchmark timings instead of raw SQL logging. */\n  benchmark?: boolean;\n  /** If `true`, logs bound parameter values. */\n  logQueryParameters?: boolean;\n  /** Optional label prefixed to the log line. */\n  queryLabel?: string;\n  /** Include definitions passed by the user. */\n  include?: IncludeOptions[] | boolean;\n  /** Resolved include names used by builder. */\n  includeNames?: readonly string[];\n  /** Resolved include map used by parser. */\n  includeMap?: IncludeMap;\n  /** The attributes originally selected by the user. */\n  originalAttributes?: readonly string[];\n  /** The attributes currently selected by the query. */\n  attributes?: readonly string[];\n  /** If `true`, skip error wrapping and re-throw database errors as-is. */\n  rawErrors?: boolean;\n  [key: string]: unknown;\n}\n\nexport interface AbstractQueryFormatBindOptions {\n  /** skip unescaping $$ */\n  skipUnescape: boolean;\n  /** do not replace (but do unescape $$) */\n  skipValueReplace: boolean;\n}\n\nexport class AbstractQuery {\n  declare sql: string;\n  readonly uuid: string;\n  readonly connection: AbstractConnection;\n  readonly instance?: Model | undefined;\n  readonly model?: ModelStatic | undefined;\n  readonly sequelize: Sequelize;\n  options: AbstractQueryOptions;\n\n  constructor(\n    connection: AbstractConnection,\n    sequelize: Sequelize,\n    options?: AbstractQueryOptions,\n  ) {\n    this.uuid = randomUUID();\n    this.connection = connection;\n    this.sequelize = sequelize;\n\n    const mergedOptions: AbstractQueryOptions = {\n      plain: false,\n      raw: false,\n      logging: console.debug,\n      ...options,\n    };\n\n    this.instance = mergedOptions.instance;\n    this.model = mergedOptions.model;\n    this.options = mergedOptions;\n    this.checkLoggingOption();\n\n    if (mergedOptions.rawErrors) {\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n\n  async logWarnings<T>(results: T): Promise<T> {\n    const warningResultsRaw = await this.run('SHOW WARNINGS');\n    const warningRows = Array.isArray(warningResultsRaw) ? warningResultsRaw : [];\n    const warningMessage = `${this.sequelize.dialect.name} warnings (${this.connection.uuid || 'default'}): `;\n    const messages: string[] = [];\n\n    for (const warningRow of warningRows) {\n      if (!isIterable(warningRow)) {\n        continue;\n      }\n\n      for (const warningResult of warningRow) {\n        if (\n          warningResult &&\n          typeof warningResult === 'object' &&\n          Object.hasOwn(warningResult, 'Message') &&\n          typeof (warningResult as { Message: unknown }).Message === 'string'\n        ) {\n          messages.push((warningResult as { Message: string }).Message);\n          continue;\n        }\n\n        const keysFunction = (warningResult as { keys?(): Iterable<string> })?.keys;\n        if (!keysFunction) {\n          continue;\n        }\n\n        const iterator = keysFunction.call(warningResult);\n        if (!isIterable(iterator)) {\n          continue;\n        }\n\n        const record = warningResult as Record<string, unknown>;\n        for (const objectKey of iterator) {\n          messages.push([objectKey, record[objectKey]].join(': '));\n        }\n      }\n    }\n\n    this.sequelize.log(warningMessage + messages.join('; '), this.options);\n\n    return results;\n  }\n\n  formatError<T extends Error>(error: T, errStack?: string): T {\n    if (errStack) {\n      error.stack = errStack;\n    }\n\n    return error;\n  }\n\n  async run(_sql: string, _parameters?: unknown, _options?: unknown): Promise<unknown> {\n    throw new Error(\"The run method wasn't overwritten!\");\n  }\n\n  private checkLoggingOption(): void {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.debug;\n    }\n  }\n\n  protected getInsertIdField(): string {\n    return 'insertId';\n  }\n\n  protected getUniqueConstraintErrorMessage(field?: string): string {\n    if (!field) {\n      return 'Must be unique';\n    }\n\n    const message = `${field} must be unique`;\n\n    if (!this.model) {\n      return message;\n    }\n\n    const model = this.model;\n\n    for (let i = 0; i < model.getIndexes().length; i++) {\n      const index = model.getIndexes()[i];\n      if (!index.unique || !index.fields) {\n        continue;\n      }\n\n      const normalizedField = field.replaceAll('\"', '');\n      const matches = index.fields.some(\n        indexField => typeof indexField === 'string' && indexField === normalizedField,\n      );\n\n      if (matches && index.msg) {\n        return index.msg;\n      }\n    }\n\n    return message;\n  }\n\n  protected isRawQuery(): boolean {\n    return this.options.type === QueryTypes.RAW;\n  }\n\n  protected isUpsertQuery(): boolean {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n\n  protected isInsertQuery(\n    results?: Record<string, unknown>,\n    metaData?: Record<string, unknown>,\n  ): boolean {\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n\n    const sql = this.sql?.toLowerCase() ?? '';\n    let result = true;\n    result &&= sql.startsWith('insert into');\n    result &&= !results || Object.hasOwn(results, this.getInsertIdField());\n    result &&= !metaData || Object.hasOwn(metaData, this.getInsertIdField());\n\n    return result;\n  }\n\n  protected handleInsertQuery(\n    results?: Record<string, unknown>,\n    metaData?: Record<string, unknown>,\n  ): void {\n    if (!this.instance) {\n      return;\n    }\n\n    const autoIncrementAttribute = this.model?.modelDefinition?.autoIncrementAttributeName;\n\n    if (!autoIncrementAttribute) {\n      return;\n    }\n\n    const id = results?.[this.getInsertIdField()] ?? metaData?.[this.getInsertIdField()] ?? null;\n    const instanceRecord = this.instance as unknown as Record<string, unknown>;\n    instanceRecord[autoIncrementAttribute] = id;\n  }\n\n  protected isShowIndexesQuery(): boolean {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n\n  protected isShowConstraintsQuery(): boolean {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n\n  protected isDescribeQuery(): boolean {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n\n  protected isSelectQuery(): boolean {\n    return this.options.type === QueryTypes.SELECT;\n  }\n\n  protected isBulkUpdateQuery(): boolean {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n\n  protected isDeleteQuery(): boolean {\n    return this.options.type === QueryTypes.DELETE;\n  }\n\n  protected isUpdateQuery(): boolean {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n\n  /**\n   * Post-processes a SELECT result set according to the query options:\n   * - Remaps field names when `fieldMap` is provided.\n   * - Returns raw nested objects when `raw` and `nest` are set.\n   * - Groups JOINed rows into nested include graphs and builds model instances otherwise.\n   *\n   * @param results - The raw rows returned by the driver.\n   * @returns Raw objects or built model instances depending on `options`.\n   */\n  protected handleSelectQuery(results: Array<Record<string, unknown>>): unknown {\n    let processedResults: Array<Record<string, unknown>> = results;\n    let result: unknown = null;\n\n    if (this.options.fieldMap && typeof this.options.fieldMap === 'object') {\n      processedResults = processedResults.map(row =>\n        remapRowFields(row, this.options.fieldMap as Record<string, string>),\n      );\n    }\n\n    if (this.options.raw) {\n      let precompiled: PrecompiledTransform | undefined;\n\n      const rawRows = processedResults.map(row => {\n        if (!this.options.nest) {\n          return row;\n        }\n\n        if (!precompiled) {\n          precompiled = precompileKeys(Object.keys(row));\n        }\n\n        const target: Record<string, unknown> = {};\n        transformRowWithPrecompiled(row, precompiled, target);\n\n        // If this row contains keys not present in the initial precompilation,\n        // compile and set them once and extend the cache for subsequent rows.\n        const rowKeys = Object.keys(row);\n        for (let i = 0; i < rowKeys.length; ++i) {\n          const k = rowKeys[i];\n          if (!precompiled.index.has(k)) {\n            const path = tokenizePath(k);\n            const v = row[k];\n            if (v !== undefined) {\n              setByPathArray(target, path, v);\n            }\n\n            precompiled.index.set(k, path);\n            precompiled.compiled.push({ sourceKey: k, path });\n          }\n        }\n\n        return target;\n      });\n\n      result = rawRows;\n    } else if (this.options.hasJoin === true && this.model) {\n      const model = this.model;\n      const includeMap = this.options.includeMap;\n\n      const joinedResults = AbstractQuery._groupJoinData(\n        processedResults,\n        {\n          model,\n          ...(includeMap !== undefined && { includeMap }),\n          ...(this.options.includeNames !== undefined && {\n            includeNames: this.options.includeNames,\n          }),\n        },\n        {\n          checkExisting: Boolean(this.options.hasMultiAssociation),\n        },\n      );\n\n      const parsedRows = this._parseDataArrayByType(joinedResults, model, includeMap);\n      const buildOptions: BulkBuildOptionsInternal = {\n        isNewRecord: false,\n        includeNames: this.options.includeNames,\n        includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes ?? this.options.attributes,\n        raw: true,\n        comesFromDatabase: true,\n      };\n\n      const includeOption =\n        typeof this.options.include === 'boolean' ? undefined : this.options.include;\n      if (includeOption !== undefined) {\n        buildOptions.include = includeOption;\n      }\n\n      result = model.bulkBuild(\n        parsedRows as unknown as Parameters<typeof model.bulkBuild>[0],\n        buildOptions as unknown as Parameters<typeof model.bulkBuild>[1],\n      );\n    } else if (this.model) {\n      const model = this.model;\n      const parsedRows = this._parseDataArrayByType(\n        processedResults,\n        model,\n        this.options.includeMap,\n      );\n      const buildOptions: BulkBuildOptionsInternal = {\n        isNewRecord: false,\n        raw: true,\n        comesFromDatabase: true,\n        attributes: this.options.originalAttributes ?? this.options.attributes,\n      };\n\n      result = model.bulkBuild(\n        parsedRows as unknown as Parameters<typeof model.bulkBuild>[0],\n        buildOptions as unknown as Parameters<typeof model.bulkBuild>[1],\n      );\n    }\n\n    if (result == null) {\n      result = processedResults;\n    }\n\n    if (this.options.plain && Array.isArray(result)) {\n      return result.length === 0 ? null : result[0];\n    }\n\n    return result;\n  }\n\n  /**\n   * Applies attribute-type parsing to an array of value objects.\n   *\n   * @param valueArrays - Array of objects to parse in-place.\n   * @param model - The model providing attribute types for parsing.\n   * @param includeMap - Include lookup map for nested parsing.\n   * @returns The same array instance after parsing.\n   */\n  protected _parseDataArrayByType(\n    valueArrays: Array<Record<string, unknown>>,\n    model?: ModelStatic,\n    includeMap?: IncludeMap,\n  ): Array<Record<string, unknown>> {\n    for (let index = 0; index < valueArrays.length; ++index) {\n      const values = valueArrays[index];\n      this._parseDataByType(values, model, includeMap);\n    }\n\n    return valueArrays;\n  }\n\n  /**\n   * Applies attribute-type parsing to a single object. Descends into includes when present.\n   *\n   * @param values - The object to mutate with parsed values.\n   * @param model - The model providing attribute types for parsing.\n   * @param includeMap - Include lookup map for nested parsing.\n   * @returns The mutated `values` object.\n   */\n  protected _parseDataByType(\n    values: Record<string, unknown>,\n    model?: ModelStatic,\n    includeMap?: IncludeMap,\n  ): Record<string, unknown> {\n    const keys = Object.keys(values);\n    for (let index = 0; index < keys.length; ++index) {\n      const key = keys[index];\n      const nestedInclude = includeMap?.[key];\n      if (nestedInclude) {\n        const child = values[key];\n        if (Array.isArray(child)) {\n          values[key] = this._parseDataArrayByType(\n            child as Array<Record<string, unknown>>,\n            nestedInclude.model,\n            nestedInclude.includeMap,\n          );\n        } else if (child && typeof child === 'object') {\n          values[key] = this._parseDataByType(\n            child as Record<string, unknown>,\n            nestedInclude.model,\n            nestedInclude.includeMap,\n          );\n        }\n\n        continue;\n      }\n\n      const attribute = model?.modelDefinition?.attributes.get(key);\n      values[key] = this._parseDatabaseValue(values[key], attribute?.type);\n    }\n\n    return values;\n  }\n\n  /**\n   * Parses a raw database value using the attribute's data-type parser when available.\n   *\n   * @param value - The raw value to parse.\n   * @param attributeType - The normalized data type to parse with.\n   * @returns The parsed value, or the original value if no parser applies.\n   */\n  protected _parseDatabaseValue(value: unknown, attributeType?: NormalizedDataType): unknown {\n    if (value == null) {\n      return value;\n    }\n\n    if (!attributeType || !(attributeType instanceof AbstractDataType)) {\n      return value;\n    }\n\n    return attributeType.parseDatabaseValue(value);\n  }\n\n  protected isShowOrDescribeQuery(): boolean {\n    const sql = this.sql?.toLowerCase() ?? '';\n\n    return sql.startsWith('show') || sql.startsWith('describe');\n  }\n\n  protected isCallQuery(): boolean {\n    return (this.sql?.toLowerCase() ?? '').startsWith('call');\n  }\n\n  /**\n   * Logs a SQL query with optional parameters and returns a function to log completion.\n   * When benchmarking is enabled, the completion logger emits timing information.\n   *\n   * @param sql - The SQL string to log.\n   * @param debugContext - A function receiving debug messages.\n   * @param parameters - Optional bound parameters to display when enabled.\n   * @returns A callback to be invoked after query execution to finalize logging.\n   */\n  protected _logQuery(\n    sql: string,\n    debugContext: (msg: string) => void,\n    parameters?: unknown[] | Record<string, unknown>,\n  ): () => void {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters =\n      this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = '';\n\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(';') ? '' : ';';\n      logParameter = `${delimiter} with parameters ${NodeUtil.inspect(parameters)}`;\n    }\n\n    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;\n    const queryLabel = options.queryLabel ? `${options.queryLabel}\\n` : '';\n    const msg = `${queryLabel}Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`${queryLabel}Executing ${fmt}`, options);\n    }\n\n    return () => {\n      const afterMsg = `${queryLabel}Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n\n  /**\n   * Groups a flat array of JOINed rows into nested objects according to include definitions.\n   *\n   * Algorithm overview:\n   * - Sorts row keys by depth to build prefix metadata once on the first row.\n   * - For each row, computes stable identity hashes for each include prefix\n   *   using PK/unique-key values to de-duplicate repeated JOIN combinations.\n   * - Uses a global `resultMap` keyed by hash to re-use previously materialized\n   *   containers and attach children in O(1) time.\n   * - In non-dedup mode, directly builds nested objects for each row without hashing.\n   *\n   * Complexity:\n   * - First row metadata setup: O(K log K) for K keys due to depth sort.\n   * - Each subsequent row: O(K) for value assignment and at most O(depth) hash lookups.\n   *\n   * @param rows - Raw rows as returned by the driver with dotted keys.\n   * @param includeOptions - The root include options and model information.\n   * @param options - Controls whether de-duplication is applied.\n   * @returns An array of nested objects ready for model-building or raw return.\n   */\n  static _groupJoinData(\n    rows: Array<Record<string, unknown>>,\n    includeOptions: RootIncludeOptions,\n    options: AbstractQueryGroupJoinDataOptions,\n  ): Array<Record<string, unknown>> {\n    if (rows.length === 0) {\n      return [];\n    }\n\n    const rowsLength = rows.length;\n    let keys: string[] = [];\n    let keyLength = 0;\n    let keyMeta: metaEntry[] = [];\n    let prefixMeta = new Map<string, metaEntry>();\n    const checkExisting = options.checkExisting;\n\n    // eslint-disable-next-line unicorn/no-new-array -- we want a fixed length array here for optimization at scale\n    const results: Array<Record<string, unknown>> = checkExisting ? [] : new Array(rowsLength);\n    const resultMap: Record<string, Record<string, unknown>> = {};\n    const includeMap: IncludeMap = {};\n\n    for (let rowIndex = 0; rowIndex < rowsLength; ++rowIndex) {\n      const row = rows[rowIndex];\n      const freeList: Array<Record<string, unknown>> = [];\n      let prefixHashCache: Map<string, HashEntry> | undefined;\n      let topHashEntry: HashEntry | undefined;\n      let topHash = '';\n\n      if (rowIndex === 0) {\n        keys = sortByDepth(Object.keys(row));\n        keyLength = keys.length;\n        keyMeta = [];\n        prefixMeta = new Map<string, metaEntry>();\n        const prefixPartsCache = new Map<string, readonly string[]>();\n\n        for (let i = 0; i < keys.length; i++) {\n          const rawKey = keys[i];\n          const lastDotIndex = rawKey.lastIndexOf('.');\n          const prefixId = lastDotIndex === -1 ? '' : rawKey.slice(0, lastDotIndex);\n          let prefixParts = prefixPartsCache.get(prefixId);\n          if (!prefixParts) {\n            prefixParts = prefixId ? prefixId.split('.') : [];\n            prefixPartsCache.set(prefixId, prefixParts);\n          }\n\n          const prefixLength = prefixParts.length;\n          const attribute = lastDotIndex === -1 ? rawKey : rawKey.slice(lastDotIndex + 1);\n          const lastKeySegment = prefixLength ? prefixParts[prefixLength - 1] : '';\n\n          if (!Object.hasOwn(includeMap, rawKey)) {\n            resolveIncludeForKey(rawKey, prefixParts, includeOptions, includeMap);\n          }\n\n          const includeForKey = includeMap[rawKey];\n          const modelForKey = includeForKey?.model;\n          const parentPrefixId =\n            prefixLength === 0\n              ? ''\n              : prefixId.slice(0, Math.max(0, prefixId.lastIndexOf('.'))) || '';\n          const primaryKeyAttributes = modelForKey?.primaryKeyAttributes ?? [];\n          const hasUniqueKeys = modelForKey ? !isEmpty(modelForKey.uniqueKeys) : false;\n          const uniqueKeyAttributes =\n            hasUniqueKeys && modelForKey ? getUniqueKeyAttributes(modelForKey) : [];\n          const hashAttributeRowKeys = buildHashAttributeRowKeys(\n            prefixId,\n            primaryKeyAttributes,\n            uniqueKeyAttributes,\n          );\n\n          const metaEntry = {\n            key: rawKey,\n            attribute,\n            prefixParts,\n            prefixLength,\n            prefixId,\n            lastKeySegment,\n            include: includeForKey,\n            parentPrefixId,\n            primaryKeyAttributes,\n            uniqueKeyAttributes,\n            hashAttributeRowKeys,\n          };\n\n          keyMeta.push(metaEntry);\n\n          if (!prefixMeta.has(prefixId)) {\n            prefixMeta.set(prefixId, metaEntry);\n          }\n        }\n      }\n\n      let topExistsForRow = false;\n\n      if (checkExisting) {\n        topHash = getHash(includeOptions.model, row);\n        prefixHashCache = new Map<string, HashEntry>();\n        const rootEntry: HashEntry = { itemHash: topHash, parentHash: null };\n        prefixHashCache.set('', rootEntry);\n        topHashEntry = rootEntry;\n      }\n\n      let currentValues: Record<string, unknown> = checkExisting\n        ? acquireValuesObject(freeList)\n        : {};\n      const topValues = currentValues;\n      let previousMeta: metaEntry | undefined;\n\n      for (let keyIndex = 0; keyIndex < keyLength; ++keyIndex) {\n        const meta = keyMeta[keyIndex];\n        const key = keys[keyIndex];\n\n        if (previousMeta && previousMeta.prefixId !== meta.prefixId) {\n          if (checkExisting) {\n            const segmentResult = attachExistingSegment(\n              previousMeta,\n              row,\n              includeMap,\n              prefixMeta,\n              prefixHashCache,\n              currentValues,\n              resultMap,\n              freeList,\n              topHashEntry!,\n            );\n            currentValues = segmentResult.nextValues;\n            topExistsForRow ||= segmentResult.topExists;\n          } else {\n            currentValues = ensureNestedContainer(topValues, meta);\n          }\n        }\n\n        currentValues[meta.attribute] = row[key];\n        previousMeta = meta;\n      }\n\n      if (checkExisting && previousMeta) {\n        const finalTopExists = finalizeExistingRow(\n          previousMeta,\n          row,\n          includeMap,\n          prefixMeta,\n          prefixHashCache,\n          currentValues,\n          resultMap,\n          topExistsForRow,\n          freeList,\n          topHashEntry!,\n        );\n\n        if (!finalTopExists) {\n          results.push(topValues);\n        }\n\n        // Removed unused assignment to topExistsForRow\n      } else if (!checkExisting) {\n        results[rowIndex] = topValues;\n      }\n    }\n\n    return results;\n  }\n}\n"],
  "mappings": "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",
  "names": ["isEmpty", "NodeUtil"]
}
